Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 枚举类
- NOTE
<pre>在某些情况下，一个类的对象是有限而且固定的，比如季节类，它只有4个对象；再比如行星类，
目前只有9个对象。这种实例有限而且固定的类，在Java里被称为枚举类。</pre>

## 手动实现枚举类
- NOTE
<pre>如果需要手动实现枚举类，可以采用如下设计方式：
1、通过private将构造器隐藏起来。
2、把这个类的所有可能实例都使用public static final修饰的类变量来保存。
3、 如果有必要，可以提供一些静态方法，允许其他程序根据特定参数来获取与之匹配的实例。
参考：Season.java

在更早以前，程序员喜欢使用简单的静态常量来表示这种情况。
   public static final int SEASON_SPRING = 1;
    public static final int SEASON_SUMMER = 2;
    public static final int SEASON_FALL = 3;
    public static final int SEASON_WINTER = 4;
 这种定义方法简单明了，但存在如下几个问题。
 1、 类型不安全：因为上面的每个季节实际上是一个int整数，因此完全可以把一个季节当成一个
 int整数使用，例如进行加法运算SEASON_SPRING+SEASON_SUMMER，这样的代码完全正常。
2、没有命名空间：当需要使用季节时，必须在SPRING前使用SEASON_前缀，否则程序可能与
其他类中的静态常量混淆。
3、打印输出的意义不明确：当我们打印输出某个季节时，例如打印SEASON_SPRING，实际上输出
的是1，这个1很难猜测它代表了春天。
从这个意义上来看，枚举类的存在确实很有意义，但手动定义枚举类的代码量比较大，实现起来也
比较麻烦，所以Java从JDK 1.5后就增加了对枚举类的支持。</pre>

## 枚举类入门
> leftSide=`true`

- NOTE
<pre>Java 5新增了一个enum关键字（它与class、interface关键字的地位相同），用以定义枚举类。
正如前面看到的，枚举类是一种特殊的类，它一样可以有自己的Field、方法，可以实现一个或者多
个接口，也可以定义自己的构造器。一个Java源文件中最多只能定义一个public访问权限的枚举类，
且该Java源文件也必须和该枚举类的类名相同。但枚举类终究不是普通类，它与普通类有如下简单区别。
1、枚举类可以实现一个或多个接口，使用enum定义的枚举类默认继承了java.lang.Enum类，
而不是继承Object类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang. Comparable
两个接口。
2、 使用enum定义、非抽象的枚举类默认会使用final修饰，因此枚举类不能派生子类。
3、枚举类的构造器只能使用private访问控制符，如果省略了构造器的访问控制符，
则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。
4、枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远都不能产生实例。
列出这些实例时，系统会自动添加public static final修饰，无须程序员显式添加。

所有的枚举类都提供了一个values方法，该方法可以很方便地遍历所有的枚举值。

所有的枚举类都继承了java.lang.Enum类，所以枚举类可以直接使用java.lang.Enum类中所包含的方法。
java.lang.Enum类中提供了如下几个方法。
1、int compareTo(E o)：该方法用于与指定枚举对象比较顺序，同一个枚举实例只能与相同类型的
枚举实例进行比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；如果该枚举对象位于
指定枚举对象之前，则返回负整数，否则返回零。
2、String name()：返回此枚举实例的名称，这个名称就是定义枚举类时列出的所有枚举值之一。
与此方法相比，大多数程序员应该优先考虑使用toString()方法，因为toString()方法返回更加用户
友好的名称。
3、int ordinal()：返回枚举值在枚举类中的索引值（就是枚举值在枚举声明中的位置，
第一个枚举值的索引值为零）。
4、String toString()：返回枚举常量的名称，与name方法相似，但toString()方法更常用。
5、public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;enumType, String name)：
这是一个静态方法，用于返回指定枚举类中指定名称的枚举值。名称必须与在该枚举类中声明枚举值
时所用的标识符完全匹配，不允许使用额外的空白字符。
</pre>

## 枚举类的Field、方法和构造器
> leftSide=`true`

- NOTE
<pre>枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以定义Field、方法。

枚举类通常应该设计成不可变类，也就是说，它的Field值不应该允许改变，这样会更安全，而且代码
更加简洁。为此，我们应该将枚举类的Field都使用private final修饰。
因为我们将所有的Field都使用了final修饰符来修饰，所以必须在构造器里为这些Field指定初始值
（或者在定义Field时指定默认值，或者在初始化块中指定初始值，但这两种情况并不常见），因此
应该为枚举类显式定义带参数的构造器。
一旦为枚举类显式定义了带参数的构造器，列出枚举值时就必须对应地传入参数。

参考：Gender.java

</pre>

## 实现接口的枚举类
- NOTE
<pre>枚举类也可以实现一个或多个接口。与普通类实现一个或多个接口完全一样，枚举类实现一个或多个
接口时，也需要实现该接口所包含的方法。

参考：Gender.java</pre>

## 包含抽象方法的枚举类
> leftSide=`true`

- NOTE
<pre>枚举类里定义抽象方法时不能使用abstract关键字将枚举类定义成抽象类（因为系统自动会为它添加
abstract关键字），但因为枚举类需要显式创建枚举值，而不是作为父类，
所以定义每个枚举值时必须为抽象方法提供实现，否则将出现编译错误。

参考：Operation.java</pre>
